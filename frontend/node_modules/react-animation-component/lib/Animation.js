"use strict";

exports.__esModule = true;
exports.Animation = undefined;

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

var _react = require("react");

var React = _interopRequireWildcard(_react);

var _reactDom = require("react-dom");

var ReactDOM = _interopRequireWildcard(_reactDom);

require("web-library/lib/polyfills/animationFrame");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var __extends = undefined && undefined.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = undefined && undefined.__assign || Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
    }
    return t;
};
/**
 * @disc:动画库
 * @author:yanxinaliang
 * @time：2018/6/8 22:28
 * fix bug transitionEnd 未触发时执行关闭操作  需要优化
 */

var transitionEnd = function () {
    var transEndEventNames = {
        MozTransition: 'transitionend',
        WebkitTransition: 'webkitTransitionEnd',
        transition: 'transitionend'
    };
    for (var name_1 in transEndEventNames) {
        if (typeof document.body.style[name_1] === "string") {
            return transEndEventNames[name_1];
        }
    }
}();
var animationEnd = function () {
    var animsEndEventNames = {
        MozAnimation: 'animationend',
        WebkitAnimation: 'webkitAnimationEnd',
        animation: 'ainmationend'
    };
    for (var name_2 in animsEndEventNames) {
        if (typeof document.body.style[name_2] === "string") {
            return animsEndEventNames[name_2];
        }
    }
}();
var Animation = /** @class */function (_super) {
    __extends(Animation, _super);
    function Animation(props) {
        var _this = _super.call(this, props) || this;
        _this.shouldUpdateFlag = true;
        _this.cloneElement = function (ref, className, style, events) {
            var children = _this.props.children;
            //不一定是起始的样式，可能是结束的样式
            if (children) {
                return React.cloneElement(children, __assign({ className: (children.props.className || "") + " " + className, ref: ref, style: (0, _extends3["default"])({}, children.props.style || {}, style) }, events));
            } else {
                return null;
            }
        };
        _this.calcCss = function () {
            var _a = _this.props,
                _b = _a.duration,
                duration = _b === void 0 ? 300 : _b,
                delay = _a.delay,
                _c = _a.timing,
                timing = _c === void 0 ? "ease" : _c,
                start = _a.start,
                end = _a.end,
                origin = _a.origin;
            // 相对于end时start位置
            var transX = 0;
            var transY = 0;
            if (start && end) {
                if (void 0 !== start.left && void 0 !== end.left) {
                    transX = start.left - end.left;
                } else if (void 0 !== start.right && void 0 !== end.right) {
                    transX = end.right - start.right;
                }
                if (void 0 !== start.top && void 0 !== end.top) {
                    transY = start.top - end.top;
                } else if (void 0 !== start.bottom && void 0 !== end.bottom) {
                    transY = end.bottom - start.bottom;
                }
            }
            //TODO 如果不是enter则计算终点样式
            if (_this.enterOrLeave === "enter") {
                return __assign({}, end ? end : {}, { transform: "translate3d(" + transX + "px," + transY + "px,0)" + (start && void 0 !== start.scale ? " scale(" + start.scale + ")" : "") }, delay ? { transitionDelay: delay + "ms" } : {}, { transitionDuration: duration + "ms", transitionProperty: "transform,opacity", transitionTimingFunction: timing }, origin ? { transformOrigin: origin } : {}, start && void 0 !== start.opacity ? { opacity: start.opacity } : {});
            } else {
                return __assign({}, end ? end : {}, { transform: "translate3d(0,0,0)" + (start && void 0 !== start.scale ? " scale(1)" : "") }, delay ? { transitionDelay: delay + "ms" } : {}, { transitionDuration: duration + "ms", transitionProperty: "transform,opacity", transitionTimingFunction: timing }, origin ? { transformOrigin: origin } : {});
            }
        };
        _this.calcRevert = function (props) {
            var _a = props.duration,
                duration = _a === void 0 ? 300 : _a,
                delay = props.delay,
                _b = props.timing,
                timing = _b === void 0 ? "ease" : _b,
                start = props.start,
                end = props.end,
                origin = props.origin;
            // 相对于end时start位置
            var transX = 0;
            var transY = 0;
            if (start && end) {
                if (void 0 !== start.left && void 0 !== end.left) {
                    transX = start.left - end.left;
                } else if (void 0 !== start.right && void 0 !== end.right) {
                    transX = end.right - start.right;
                }
                if (void 0 !== start.top && void 0 !== end.top) {
                    transY = start.top - end.top;
                } else if (void 0 !== start.bottom && void 0 !== end.bottom) {
                    transY = end.bottom - start.bottom;
                }
            }
            return __assign({ transform: "translate3d(" + transX + "px," + transY + "px,0)" + (start && void 0 !== start.scale ? " scale(" + start.scale + ")" : "") }, delay ? { transitionDelay: delay + "ms" } : {}, { transitionDuration: duration + "ms", transitionProperty: "transform,opacity", transitionTimingFunction: timing }, origin ? { transformOrigin: origin } : {}, start && void 0 !== start.opacity ? { opacity: start.opacity } : {});
        };
        _this.onAnimationEnd = function (e) {
            var enterClass = _this.props.enterClass;
            e.target.classList.remove(enterClass);
        };
        _this.onTransitionEnd = function () {
            var onTransitionEnd = _this.props.onTransitionEnd;
            onTransitionEnd && onTransitionEnd.call(_this);
        };
        if (props.children) {
            _this.enterOrLeave = "enter";
        }
        return _this;
    }
    Animation.prototype.render = function () {
        var _this = this;
        var _a = this.props,
            children = _a.children,
            _b = _a.enterClass,
            enterClass = _b === void 0 ? "" : _b,
            animType = _a.animType;
        var style = animType === "css" ? this.calcCss() : {};
        var event = animType === "class" ? this.enterOrLeave === "enter" ? { onAnimationEnd: this.onAnimationEnd } : {} : this.enterOrLeave === "enter" ? { onTransitionEnd: this.onTransitionEnd } : {};
        // children clone
        return children ? this.cloneElement(function (ref) {
            return _this.wrapElement = ReactDOM.findDOMNode(ref);
        }, enterClass, style, event) : null;
        // return children?<div ref={(ref:HTMLDivElement)=>this.wrapElement=ref} className={(className||"")+(enterClass||"")} style={style} {...event}>{children}</div>:null;
    };
    Animation.prototype.componentDidMount = function () {
        var _a = this.props,
            children = _a.children,
            animType = _a.animType,
            start = _a.start;
        if (children && animType === "css") {
            if (this.wrapElement) {
                window.getComputedStyle(this.wrapElement).top;
                this.wrapElement.style.transform = "translate3d(0,0,0)" + (start && void 0 !== start.scale ? " scale(1)" : "");
                start && void 0 !== start.opacity && (this.wrapElement.style.opacity = "1");
            }
        }
    };
    Animation.prototype.componentDidUpdate = function () {
        var _a = this.props,
            animType = _a.animType,
            start = _a.start;
        var __this = this;
        if (this.enterOrLeave === "enter" && animType === "css" && __this.wrapElement) {
            this.wrapElement && window.getComputedStyle(__this.wrapElement).top;
            this.enterOrLeave = "";
            window.requestAnimationFrame(function () {
                __this.wrapElement && (__this.wrapElement.style.transform = "translate3d(0,0,0)" + (start && void 0 !== start.scale ? " scale(1)" : ""));
                start && void 0 !== start.opacity && __this.wrapElement && (__this.wrapElement.style.opacity = "1");
            });
        }
    };
    Animation.prototype.shouldComponentUpdate = function () {
        return this.shouldUpdateFlag;
    };
    Animation.prototype.componentWillReceiveProps = function (nextProps) {
        var _this = this;
        var beforeChildren = this.props.children;
        var children = nextProps.children,
            animType = nextProps.animType,
            leaveClass = nextProps.leaveClass;
        if (!beforeChildren && children) {
            this.enterOrLeave = "enter";
        } else if (!children && beforeChildren) {
            this.enterOrLeave = "leave";
            this.shouldUpdateFlag = false;
            if (this.wrapElement) {
                if (animType === "css") {
                    // css 离开动画 执行完成后刷新
                    var transitionEndCallback_1 = function transitionEndCallback_1() {
                        _this.wrapElement && _this.wrapElement.removeEventListener(transitionEnd, transitionEndCallback_1);
                        _this.shouldUpdateFlag = true;
                        _this.forceUpdate();
                    };
                    this.wrapElement.addEventListener(transitionEnd, transitionEndCallback_1);
                    var revertCss = this.calcRevert(nextProps);
                    for (var key in revertCss) {
                        this.wrapElement.style[key] = revertCss[key];
                    }
                } else {
                    if (leaveClass) {
                        var animationEndCallback_1 = function animationEndCallback_1() {
                            _this.wrapElement && _this.wrapElement.removeEventListener(animationEnd, animationEndCallback_1);
                            _this.shouldUpdateFlag = true;
                            _this.forceUpdate();
                        };
                        this.wrapElement.addEventListener(animationEnd, animationEndCallback_1);
                        this.wrapElement.classList.add(leaveClass);
                    } else {
                        this.shouldUpdateFlag = true;
                        this.forceUpdate();
                    }
                }
            }
        } else {
            this.enterOrLeave = "";
            this.shouldUpdateFlag = true;
        }
    };
    return Animation;
}(React.Component);
exports.Animation = Animation;